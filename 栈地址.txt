
栈的生长方向
我们知道，栈是先进后出，后进先出的数据结构。那到底是先入栈变量的内存地址大，还是后入栈的内存地址大？

如果熟悉汇编，肯定很轻松就知道肯定是先入栈的内存地址大。看汇编代码时，每push一个变量，esp寄存器就减少该变量的大小。比如push一个int变量，esp-4。

那能不能用C语言验证呢？当然可以

 

一  栈的生长方向：

  我们先后入栈二个变量a，b。如果b的内存地址确实比a小，说明栈的生长方向是由上往下的，即从高地址到低地址。

代码如下：

#define _CRT_SECURE_NO_WARNINGS
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

int main()
{
　　int a; //先声明a，a先入栈
　　int b; //后声明b，b后入栈
　　printf("a的内存地址：%d \n", &a);
　　printf("b的内存地址：%d \n", &b);
　　system("pause");
　　return 0;
}

F5运行：



看到后入栈的b确实内存地址更小。所以栈的生长方向是由上往下。

二 数组的生长方向

　　如果数组在栈区，该数组的生长方向是怎么样呢？

PS: 不管数组在栈区还是堆区，数组的生长方向都是从下往上的。也就是从低地址到高地址的。

比如数组： char buf[32];   buf[1]的内存地址肯定大于buf[0]的内存地址。代码：

int main()
{
　　char buf[32];  //这儿的数组buf是局部变量，且不是malloc,new等申请的内存，所以存放在栈区。
　　printf("buf[0]的内存地址：%d \n", &buf[0]);
　　printf("buf[1]的内存地址：%d \n", &buf[1]);
　　system("pause");
　　return 0;
}

运行结果：



可见，虽然栈的生长方向是从上往下。但是，在栈中的数组，其生长方向是从下往上的。

 

PS: 堆的生长方向是从下往上的，这儿就不演示了，可以用指针接收malloc申请的内存测试下。
